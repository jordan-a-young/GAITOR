import numpy as np
import cv2

def fit(arch):

    """
    returns the 3 coefficents of a 2nd degree polinomial fit to the points given in arch
    returns an empty array if there is no data in arch
    """

    if not arch:
        return np.array([])

    y, x = arch
    if not x.any():
        return np.array([])

    poly = np.polyfit(x, y, 2)
    return poly

def K(poly, x):

    """
    returns the crviture at point x given binomial coeeficents poly
    returns null if there is no data in poly
    """

    if not poly.any():
        return

    y_prime = lambda x: 2 * poly[0] * x + poly[1]
    y_prime2 = 2 * poly[0]

    return abs(y_prime2) / (1 + y_prime(x) ** 2) ** (3.0/2)

def isolate_back(frame, mask):

    """
    given a frame object and a top mask (rat profile)
    returns the isolated points along the curve of the rats back
    returns null if there is no data
    """

    if not frame:
        return

    copy = mask.copy()

    #get front and rear
    front = (frame.critical_points[0][2],frame.critical_points[1][2])
    rear = (frame.critical_points[0][0],frame.critical_points[1][0])
    feet = (frame.critical_points[0][3],frame.critical_points[1][3])


    if not (rear):
        return


    #bound with rectangles
    cv2.rectangle(copy, (front[0],feet[1]), rear, 255, -1)
    #cv2.rectangle(copy, (0, 0), (min_x, 2000), 0, -1)
    #cv2.rectangle(copy, (max_x, 0), (2000, 2000), 0, -1)
    copy2 = copy.copy()
    #cv2.imshow('copy',copy2)
    edge = cv2.Canny(copy,0,65)
    cv2.imshow('edge',edge)
    try:
        #arch = edge
        cnts,h = cv2.findContours(copy2,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)

        cnts = sorted(cnts,key=cv2.contourArea,reverse=True)[:2]
        arch = cnts[0]
        for c in cnts:

            peri = cv2.contourArea(c)
            peri2 = cv2.contourArea(arch)
            #print "peri : "+ str(peri)

            if peri <peri2:
                approx = cv2.approxPolyDP(c,1,True)
                print "works"
                print len(approx)
                arch = approx


        cv2.drawContours(mask,[arch],0,255/2,-1)
    except:
        print "couldnt create contour"


    #print "arch"
    #print arch
    cv2.imshow('back',mask)
    #cv2.imshow('copy',copy)
    cv2.waitkey(0)


    #return indexable array using canny edge finder to isolate the edge of the rat
    #return np.where(arch != 0)
    return mask

def get_arch_data(frame, mask):

    """
    returns the polynomial coeffecients and curviture of the arch of the
    back of the rat detected, given a frame object and a top mask (rat profile)
    returns null if there is no data
    """

    #get isolated vector using calcualted limits
    arch = isolate_back(frame, mask)
    #print "canny arch"
    #print arch
    if not poly.any():
        return np.array([]), None

    return poly, K(poly, frame.critical_points[1])

""" example usage
if __name__ == "__main__":

        import trial_video
        import numpy as np
        import itertools
        import frame

        trial = trial_video.trial_video("/home/nick/Desktop/gait_pics_1-5/green_bg_flipped.mp4")
        trial.set_horizon(255)
        trial.set_thresh_vals(98.1,98.7)

        frame_list  = list()

        while 1:

            ret, raw = trial.get_raw_frame()

            if not ret:
                break

            this_frame = frame.get_next_frame(trial)

            if not this_frame:
                break

            #peak of arch, for plotting
            peak = this_frame.critical_points[1]

            #isolated back, for plotting
            back = isolate_back(this_frame, trial.get_top_mask())

            #this data quantifies the arch of the rat's back
            poly, k = get_arch_data(this_frame, trial.get_top_mask())

            #draw the back
            if back:
                raw[back] = (100, 0, 0)

            #if there is any polinomial data
            if poly.any():

                #fit data to curve
                f = np.poly1d(poly) #function fits polinomial curve
                x = back[1].astype(int) #x-values of the arch
                curve = (f(x).astype(int), x) #y-values of the fitted arch

                #line drawn representing the inverse of the curviture, longer line = flatter back
                cv2.line(raw, (peak, int(f(peak))), (peak, int(f(peak - (k ** -1)))), (100, 0, 100),  5 )

                #highlight fitted curve
                raw[curve] = (0, 255, 0)

            cv2.imshow('', raw)
            if cv2.waitKey(60) & 0xFF == ord('q'):
                break
"""
