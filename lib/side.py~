import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from scipy.ndimage.filters import gaussian_filter as flt




class side():
    '''
    analysis of rodent side frame
    calcultes position and velocity
    '''

    def __init__(self, side_position,fps,convertion=116.84,frame_width=None):
        
        
        #get the x values for the side position
        self.side_x = [s[0] for s in side_position]
        frames = len(self.side_x)

        self.convertion = convertion
        self.frame_width = frame_width

        #convert pixels to cm
        self.convert_to_cm()

        #find the amount of seconds for video
        self.seconds = float(frames/fps)

        # set bin size for velocity analysis
        self.calc_bin_size()

        self.calc_vel_pos()
        self.calc_bin_vel_pos()
        self.calc_Xvel()

    def show(self):
        plt.show()

    
    def calc_bin_size(self):
        ''' 
        calculate bin_size based on  convertion
        '''

        self.bin_size = 2


    def calc_vel_pos(self):
        '''
        calculate velocity and position 
        '''

        displacement = list()
        position = list()


        for i in range(len(self.side_x)):
            
            if ((i+1)%2) == 0:
                    
                current = float(self.side_x[i])
                previous = float(self.side_x[i-1])
                change = current - previous
                avg = current + previous
                avg = avg/2
                displacement.append(change)
                position.append(avg)

            else:
                pass

        disp = np.array(displacement)
        
        self.position = np.array(position)

        time_increment = float(self.seconds)/float(len(self.side_x))


        vel = [ float(d)/(2.0*time_increment) for d in disp]
        self.velocity = np.array(vel)

    
 
    def calc_bin_vel_pos(self):
        '''
        return the figure for displacement by velocity
        '''

        vel_size = len(self.velocity)
        remainder = vel_size%self.bin_size
        new_vel = [ v for v in self.velocity]
        new_pos = [p for p in self.position]

        for i in range(remainder):
            new_vel.append(0)
            new_pos.append(0)

        vel = np.array(new_vel)
        pos = np.array(new_pos)
        row = len(vel)/self.bin_size

        vel =  np.reshape(vel,(row,self.bin_size))
        pos =  np.reshape(pos,(row,self.bin_size))

        self.bin_velocity = np.mean(vel,axis=1)
        self.bin_position = np.mean(pos,axis=1)
        print "Bin Vel: " + str(len(self.bin_velocity)) +"Pos Size" +  str(len(self.bin_position))
       

    def calc_Xvel(self):
        ''' 
        calculate the average velocity
        '''

        new_vel = self.velocity[~np.isnan(self.velocity)]
        self.mean_vel = np.mean(new_vel)

    def get_Xvel(self):

        return self.mean_vel
       
    def convert_to_cm(self):
        ''' convert pixels to centimeters
        '''
        if self.frame_width:

            maxPixel = self.frame_width
            temp = self.side_x
            self.side_x = [(float(d)/float(maxPixel))*self.convertion for d in temp ]
            #print self.side_x
        else:
            pass


    def plot(self):
        ''' 
        plot position by velocity 
        '''
    
        x = np.nan_to_num(self.position)
        y = np.nan_to_num(self.velocity)

        fig, ax = plt.subplots()

        ax.plot(x,y)
        ax.scatter(x,y)

        title = ax.set_title('Velocity Plot')
        ax.set_xlabel('Position')
        ax.set_ylabel('Velocity')

        return fig



    def error_corr(self, p):
        #replace invalide positions
        
        for i, x in enumerate(p):
            try:
                if x < p[i-1]:
                    p[i] = p[i-1]

                else:
                    pass


            except:
                pass

        return p

    def outlier(self, v):
        #remove outliers that are 
        #beyond 2 standard dev

        v1 = [v[i] if abs(x-np.mean(v))<2*np.std(v) else v[i-1] for i,x in enumerate(v)]

        return v1



