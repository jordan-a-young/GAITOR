import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d

class steps():
    """
    analyze paw data retrived from 
    frame class
    """



    def __init__(self,paw_list,list_size,fps,convertion=116.84,frame_width=None):
        """
        initialize list of paws, size of list and 
        frame per second
        """
        
        self.convertion = convertion
        self.frame_width =float(frame_width)

        self.FRONT = 1
        self.BACK = 0
        self.RIGHT = 1
        self.LEFT = 0

        #plot value of paw
        self.FR = 2
        self.FL = 3
        self.BR = 1
        self.BL = 4

        self.list_size = list_size
        self.paw_list = paw_list
        self.seconds = list_size/fps


        #number of steps per each paw
        self.front_right_steps = 0
        self.front_left_steps = 0
        self.back_right_steps = 0
        self.back_left_steps = 0

        
        #create graph per foot and stride lenght
        print "starting ....."
       
        self.FR_list = list()
        self.FL_list = list()
        self.BR_list = list()
        self.BL_list = list()

        #list of stride lenghts
        self.FR_stride  = list()
        self.FL_stride = list()
        self.BR_stride = list()
        self.BL_stride = list()


        #variability
        self.FR_var = list()
        self.FL_var = list()    
        self.BR_var = list()
        self.BL_var = list()

        #cadence
        self.cadence = None

        self.analyze()

    def  analyze_front_right(self):
        """
        count the amount of  paw present 
        following right paw absence
        """

        paw_found = False
        previous_paw = 0
        current_paw = 0

        for i in xrange(self.list_size):

            try:
                
                if( self.paw_list[i][self.FRONT][self.RIGHT] 
                   and not self.paw_list[i-1][self.FRONT][self.RIGHT]):
                    #if the paw was previously in the air and in now down 
                    #increment the number of steps
                    self.front_right_steps +=1
                    paw_found = True


                    #add value to stride lenght
                    paw = self.paw_list[i][self.FRONT][self.RIGHT]
                    previous_paw = current_paw
                    current_paw = paw[0]
                    s_value = current_paw -  previous_paw
                    self.FR_stride.append(s_value)

                    
                if(self.paw_list[i][self.FRONT][self.RIGHT]):
                    #if there is a paw present add to graph array
                    value = self.FR
                    self.FR_list.append(value)

                if( not self.paw_list[i][self.FRONT][self.RIGHT]):
                    #if there was a paw in previous frame and its no longer there
                    paw_found = False
                    value = None
                    self.FR_list.append(value)

            except:
                pass

    def analyze_front_left(self):
        """
        count the amount of  paw present 
        following left paw absence
        """

        paw_found = False
        previous_paw = 0
        current_paw = 0
       
        for i in xrange(self.list_size):

            try:

                if( self.paw_list[i][self.FRONT][self.LEFT] 
                   and not self.paw_list[i-1][self.FRONT][self.LEFT]):
                    #if the paw was previously in the air and in now down 
                    #increment the number of steps
                    self.front_left_steps +=1
                    paw_found = True
                    
                    

                    #add value to stride lenght
                    paw = self.paw_list[i][self.FRONT][self.LEFT]
                    previous_paw = current_paw
                    current_paw = paw[0]
                    s_value = current_paw - previous_paw
                    self.FL_stride.append(s_value)

                if(self.paw_list[i][self.FRONT][self.LEFT] ):
                    #if there is paw present add to the graph list
                    value = self.FL
                    self.FL_list.append(value)


                if( not self.paw_list[i][self.FRONT][self.LEFT]):
                    #if there was a paw in previous frame and its no longer there
                    paw_found = False
                    value = None
                    self.FL_list.append(value)


            except:
                pass

    def analyze_back_right(self):
        """
        count the amount of  paw present 
        following right paw absence
        """

        paw_found = False
        previous_paw = 0
        current_paw = 0

        for i in xrange(self.list_size):

            try:

                if( self.paw_list[i][self.BACK][self.RIGHT] 
                   and not self.paw_list[i-1][self.BACK][self.RIGHT]):
                    #if the paw was previously in the air and in now down 
                    #increment the number of steps
                    self.back_right_steps +=1
                    paw_found = True

                    

                    #add value to stride lenght
                    paw = self.paw_list[i][self.BACK][self.RIGHT] 
                    previous_paw = current_paw
                    current_paw = paw[0]
                    s_value = current_paw - previous_paw
                    self.BR_stride.append(s_value)

                if(self.paw_list[i][self.BACK][self.RIGHT] ):
                    #if there is a paw present add to the paw graph
                    value = self.BR
                    self.BR_list.append(value)



                if( not self.paw_list[i][self.BACK][self.RIGHT]):
                    #if there was a paw in previous frame and its no longer there
                    paw_found = False
                    value = None
                    self.BR_list.append(value)

            except:
                pass

    def analyze_back_left(self):
        """
        count the amount of  paw present 
        following left paw absence
        """

        paw_found = False
        previous_paw = 0 
        current_paw = 0

        for i in xrange(self.list_size):

            try:

                if( self.paw_list[i][self.BACK][self.LEFT]
                   and not self.paw_list[i-1][self.BACK][self.LEFT]):
                    #if the paw was previously in the air and in now down 
                    #increment the number of steps
                    self.back_left_steps +=1
                    paw_found = True


                    #add value to stride lenght
                    paw = self.paw_list[i][self.BACK][self.LEFT]
                    previous_paw = current_paw
                    current_paw = paw[0]
                    s_value = current_paw - previous_paw
                    self.BL_stride.append(s_value)

                if(self.paw_list[i][self.BACK][self.LEFT]):
                    #if there is a paw present add to paw graph
                    value = self.BL
                    self.BL_list.append(value)


                if( not self.paw_list[i][self.BACK][self.LEFT]):
                    #if there was a paw in previous frame and its no longer there
                    paw_found = False
                    value = None
                    self.BL_list.append(value)
        
            except:
                pass

    def plot_paw(self,linewidth=10):
        #draw a line on a plane representing the paw
        print" Starting the plot..."
        FR = np.array(self.FR_list)
        FL = np.array(self.FL_list)
        BR = np.array(self.BR_list)
        BL = np.array(self.BL_list)
        s_fr = FR.shape[0]
        s_fl = FL.shape[0]
        s_br = BR.shape[0]
        s_bl = BL.shape[0]
        i_fr = float(self.seconds)/float(s_fr)
        i_fl = float(self.seconds)/float(s_fl)
        i_br = float(self.seconds)/float(s_br)
        i_bl = float(self.seconds)/float(s_bl)
        x_fr = np.arange(0,self.seconds,i_fr)
        x_fl = np.arange(0,self.seconds,i_fl)
        x_br = np.arange(0,self.seconds,i_br)
        x_bl = np.arange(0,self.seconds,i_bl)


        fig, ax = plt.subplots()
        
        ax.plot(x_fr,FR,'-',label='FR',linewidth = linewidth)
        ax.plot(x_fl,FL,'-',label='FL',linewidth = linewidth)  
        ax.plot(x_br,BR,'-',label='BR',linewidth = linewidth)  
        ax.plot(x_bl,BL,'-',label='BL',linewidth = linewidth)
        
        legend = ax.legend(loc='upper right',shadow=True)
        axis = ax.axis([0,self.seconds,0,5])
        title = ax.set_title('Gait Plot')
        x_lable = ax.set_xlabel('seconds')
        y_label = ax.set_ylabel('Paw')
        
        #plt.show()
        print "finished...."
        return fig

        
    def analyze(self):
        #initialize analysis of paw frame data 

        self.analyze_front_right()
        self.analyze_front_left()
        self.analyze_back_right()
        self.analyze_back_left()
   

        self.set_cadence()

        self.set_variability()
        
        self.print_info()
    
    def set_cadence(self):
        #total number of steps per sec
        total_steps = (self.front_left_steps + self.front_right_steps +
                      self.back_left_steps + self.back_right_steps)


        self.cadence = total_steps / self.seconds

    def set_variability(self):
        #standard div of stride lenght
        FR = np.array(self.FR_stride)
        FL = np.array(self.FL_stride)
        BR = np.array(self.BR_stride)
        BL = np.array(self.BL_stride)
        
        #convert stride lenght to cm
        self.FR_stride = FR
        self.FL_stride = FL
        self.BR_stride = BR
        self.BL_stride = BL

        try:
            self.FR_stride = np.delete(self.FR_stride,0)
            self.FL_stride = np.delete(self.FL_stride,0)
            self.BR_stride = np.delete(self.BR_stride,0)
            self.BL_stride = np.delete(self.BL_stride,0)
        except:
            pass
            
        
        self.FR_var = float(np.std(self.FR_stride))
        self.FL_var = float(np.std(self.FL_stride))
        self.BR_var = float(np.std(self.BR_stride))
        self.BL_var = float(np.std(self.BL_stride))

        self.FR_var = (self.FR_var/self.frame_width)*self.convertion
        self.FL_var = (self.FL_var/self.frame_width)*self.convertion
        self.BR_var = (self.BR_var/self.frame_width)*self.convertion
        self.BL_var = (self.BL_var/self.frame_width)*self.convertion

    def print_info(self):

        #save test analysis to csv
        np.savetxt("fr_stride",self.FR_stride,delimiter=",")
        np.savetxt("fl_stride",self.FL_stride,delimiter=",")
        np.savetxt("br_stride",self.BR_stride,delimiter=",")
        np.savetxt("bl_stride",self.BL_stride,delimiter=",")
        print "width: " + str(self.frame_width)




    def get_variable(self):
        #get variable of steps

        return self.cadence, self.FR_var, self.FL_var,self.BR_var,self.BL_var




class side():
    '''
    analysis of rodent side frame
    calcultes position and velocity
    '''

    def __init__(self, side_position,fps,convertion=116.84,frame_width=None):
        
        
        #get the x values for the side position
        self.side_x = [s[0] for s in side_position]
        frames = len(self.side_x)

        self.convertion = convertion
        self.frame_width = frame_width

        #convert pixels to cm
        self.convert_to_cm()

        #find the amount of seconds for video
        self.seconds = float(frames/fps)

        # set bin size for velocity analysis
        self.calc_bin_size()

        self.calc_vel_pos()
        self.calc_bin_vel_pos()
        self.calc_Xvel()

    def show(self):
        plt.show()

    
    def calc_bin_size(self):
        ''' 
        calculate bin_size based on  convertion
        '''

        self.bin_size = 2


    def calc_vel_pos(self):
        '''
        calculate velocity and position 
        '''

        displacement = list()
        position = list()


        for i in range(len(self.side_x)):
            
            if ((i+1)%2) == 0:
                    
                current = float(self.side_x[i])
                previous = float(self.side_x[i-1])
                change = current - previous
                avg = current + previous
                avg = avg/2
                displacement.append(change)
                position.append(avg)

            else:
                pass

        disp = np.array(displacement)
        
        self.position = np.array(position)

        time_increment = float(self.seconds)/float(len(self.side_x))


        vel = [ float(d)/(2.0*time_increment) for d in disp]
        self.velocity = np.array(vel)

    
 
    def calc_bin_vel_pos(self):
        '''
        return the figure for displacement by velocity
        '''

        vel_size = len(self.velocity)
        remainder = vel_size%self.bin_size
        new_vel = [ v for v in self.velocity]
        new_pos = [p for p in self.position]

        for i in range(remainder):
            new_vel.append(0)
            new_pos.append(0)

        vel = np.array(new_vel)
        pos = np.array(new_pos)
        row = len(vel)/self.bin_size

        vel =  np.reshape(vel,(row,self.bin_size))
        pos =  np.reshape(pos,(row,self.bin_size))

        self.bin_velocity = np.mean(vel,axis=1)
        self.bin_position = np.mean(pos,axis=1)
        print "Bin Vel: " + str(len(self.bin_velocity)) +"Pos Size" +  str(len(self.bin_position))
       

    def calc_Xvel(self):
        ''' 
        calculate the average velocity
        '''

        new_vel = self.velocity[~np.isnan(self.velocity)]
        self.mean_vel = np.mean(new_vel)

    def get_Xvel(self):

        return self.mean_vel
       
    def convert_to_cm(self):
        ''' convert pixels to centimeters
        '''
        if self.frame_width:

            maxPixel = self.frame_width
            temp = self.side_x
            self.side_x = [(float(d)/float(maxPixel))*self.convertion for d in temp ]
            #print self.side_x
        else:
            pass


    def plot(self):
        ''' 
        plot position by velocity 
        '''
    
        x = np.nan_to_num(self.position)
        y = np.nan_to_num(self.velocity)

        fig, ax = plt.subplots()

        ax.plot(x,y)
        ax.scatter(x,y)

        title = ax.set_title('Velocity Plot')
        ax.set_xlabel('Position')
        ax.set_ylabel('Velocity')

        return fig







        
